{"_id": "aes-js", "_rev": "40-d42f59c900197d3d7625c1410d1ba3e6", "name": "aes-js", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "dist-tags": {"latest": "3.1.2", "beta": "4.0.0-beta.5"}, "versions": {"0.0.1": {"name": "aes-js", "version": "0.0.1", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "7c3a66abf3781d132ce2da42561a94a4f8658d04", "_id": "aes-js@0.0.1", "_shasum": "024009523e4495ddbf7fc2ecaf47680faf5fc3d4", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "024009523e4495ddbf7fc2ecaf47680faf5fc3d4", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.0.1.tgz", "integrity": "sha512-KZtInCHfwWvmkU0tY47T/O4InBu99jKpfyo+oHy7qWVIgYCIJKxBh8fMYi7MLWfz6N+5DLTGXjnFC8n4QQl2wQ==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDlgijkZ2m0AnALreGkSbfZmSI9vAzMg+3qXk94uIrfxwIhAL+y1Fdq+Vc2tHrq6Kg6caShIhytxOPe5O/azjzX8G4y"}]}, "directories": {}}, "0.0.2": {"name": "aes-js", "version": "0.0.2", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "aes-js@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "53f4f3ac8f63be318de0f439b9ba2a0b5264de43", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.0.2", "_shasum": "be0580b80be82452208bf9a2d2fd3b735b2d3ea8", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "be0580b80be82452208bf9a2d2fd3b735b2d3ea8", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.0.2.tgz", "integrity": "sha512-W/m3xT2cfI4sOMywlOoYskFFhp5YhBXPlZWibjVrEiV9WSh1lMoGIoDYZatIzRnOZwvr8vf2OOwXIV46Dc5poA==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQD+Csf14PVz1ZVy7oscDbR8zSqYI5al3CXUVh7B8lGmwwIgR1RN5pR+OJyJCxiZ3lRVNWzxg3JMt5iMe6MxFf8J33Q="}]}, "directories": {}}, "0.1.0": {"name": "aes-js", "version": "0.1.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "aes-js@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "84bbd40f694ce08518439e76d06f5a7b67b68702", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.1.0", "_shasum": "3b124885ce607a9974963b519636951ceb3b203f", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "3b124885ce607a9974963b519636951ceb3b203f", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.1.0.tgz", "integrity": "sha512-PgJwsW00PWWcyRIMptv7eXJw/05BzblyEnOFl0U/jTbcVVoaQv1mhWBdVCrchguiLlUZB+Wx1AXqxNpVavsSNQ==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCICPdwtr/lZ5kWNkCRIF1Uip2pXOLy5gXjil1sWkZq34iAiBe9jo6TlEkKIHjFSwmbwTTOtMPVa7PbR+3uQ/FOwmSLg=="}]}, "directories": {}}, "0.2.0": {"name": "aes-js", "version": "0.2.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "aes-js@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "d1290cf7b13011366b7b0913cacb5010b8b5bce4", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.2.0", "_shasum": "ee88f81fa55efd3fd48112179c453b7aab64e5a3", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "ee88f81fa55efd3fd48112179c453b7aab64e5a3", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.2.0.tgz", "integrity": "sha512-kWXyllcM6oNweaiAN5VZnOzEoNZ3hgZMNtB7Wmv47eX4lxY8qQEHQvkhU6dr5FHyNUaFEgbwWTbVQpcl8kMLhg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQCBiDkSy/oW0nOMJcgvE/5PSNetAbu0Ib86ixUTORXFZAIgAN63W24oyLYFBFKM5BjMpYN3MG9GYnevM1xGu4Sdbkk="}]}, "directories": {}}, "0.2.1": {"name": "aes-js", "version": "0.2.1", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "aes-js@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "19926bfa3391dbab119c6de0fd7c529055aab01b", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.2.1", "_shasum": "21e69a443df79c3aa727aff0d63f169003142ba0", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "21e69a443df79c3aa727aff0d63f169003142ba0", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.2.1.tgz", "integrity": "sha512-KO7PT4NzBzcSJuHuJ6aILb61jDI8Tf7a9AIRQWmvhf0IQYCN1aVLiC6/bJWOGhvv7eSLyatxg7PY1AEsSpz8Cw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDk/6MOAQbHIwiUvmopOTVGR0RHtirj66z7XVpKr7ZqJAIhAJikAZlVZZvJ7OVQ4T+UNYCut0G/pIwMVqSTziaxKwQ9"}]}, "directories": {}}, "0.2.2": {"name": "aes-js", "version": "0.2.2", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "aes-js@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "11b4ad4a7df344e5111483112c66875803e03351", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.2.2", "_shasum": "e57c5b0a29323b2c3f18e4bdb6f20c4ab6e2ec6a", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "e57c5b0a29323b2c3f18e4bdb6f20c4ab6e2ec6a", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.2.2.tgz", "integrity": "sha512-TzViGlSo8ho1szLAy8F05oz94xfMrPNFH48j2QHZkRyBEO8z8QPucljAs3lCMHDfTKcCxfgjegm5RiWa/XhHFw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIExQWG+UlvrI1U5C2BwTEzl/qSE07eIpe9gxqLm2c+mHAiEA3Tpjpa0HVIbJDHkpHSXnRGhKk0y4TxHpCiHzN2a4neU="}]}, "_npmOperationalInternal": {"host": "packages-6-west.internal.npmjs.com", "tmp": "tmp/aes-js-0.2.2.tgz_1454428723587_0.8871503286063671"}, "directories": {}}, "0.2.3": {"name": "aes-js", "version": "0.2.3", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js && node test/test-buffer.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "785c00df822c06e2076b71f6e23665e79061494f", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.2.3", "_shasum": "1592f2f265104a4cc1248d0d6406e32ac380e083", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "1592f2f265104a4cc1248d0d6406e32ac380e083", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.2.3.tgz", "integrity": "sha512-YR3acn1qiXhuxoYH060Cz8rysTyYbqjkfuL9hcjQdxjPMH7fw7ENRkunzKlwIHLh1S0dqYHw2YcOstiKZx/Zsw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIAg+N3URcdYLtb1Q2GRmWvWxENJ0W+8FcGBmyAeZdic7AiEAqZPnvptp8AvPfXwdsYOL2UawcowZek59H2ucvzdrmTw="}]}, "_npmOperationalInternal": {"host": "packages-5-east.internal.npmjs.com", "tmp": "tmp/aes-js-0.2.3.tgz_1456290172167_0.11849974258802831"}, "directories": {}}, "0.2.4": {"name": "aes-js", "version": "0.2.4", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js && node test/test-buffer.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "79f330d770d536d1fbb7c0845b41b60f05e5e385", "homepage": "https://github.com/ricmoo/aes-js", "_id": "aes-js@0.2.4", "_shasum": "94b881ab717286d015fa219e08fb66709dda5a3d", "_from": ".", "_npmVersion": "2.5.1", "_nodeVersion": "0.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "94b881ab717286d015fa219e08fb66709dda5a3d", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-0.2.4.tgz", "integrity": "sha512-Ohbx4dcH7PB0E4Z/CpRT0qygXN2TVDJ4B43xtdoz77/tRU6s61umfZoQpek17Sz6ROrWsjisfWqqddWq8q75Ew==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCIHiwDODshDJ0yW0vPlqtJlQQ7kE+qCVy5WSogcpfvIyqAiATWm5aRqtqfX9x1jqzDUxSaruXporA0eoPDUxTBs9cqg=="}]}, "_npmOperationalInternal": {"host": "packages-5-east.internal.npmjs.com", "tmp": "tmp/aes-js-0.2.4.tgz_1456558944058_0.594102936796844"}, "directories": {}}, "1.0.0": {"name": "aes-js", "version": "1.0.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js && node test/test-buffer.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "f4e9eba001b556179fba978288cd1d7714fc9dfa", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@1.0.0", "_shasum": "41300dfc4efe4fc6c85ccce48906d54e05fe2a41", "_from": ".", "_npmVersion": "2.14.20", "_nodeVersion": "4.4.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "dist": {"shasum": "41300dfc4efe4fc6c85ccce48906d54e05fe2a41", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-1.0.0.tgz", "integrity": "sha512-EQKxi2x3QsSOtnd0f6yhIEYHkTQFUNFMmof04GP9FV5CjbxErepmrzRuI+4ZYN7pXj7OlmsVSisgN7rDB2JdRg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIACE3M4u1ysi09pkkP1c3+PMQFbgnLpR5L8eHBoNZZ/5AiEA/7rCXa11hYpr+Z3DLLNwzqymN980TIFxbvXJ1IagYOU="}]}, "_npmOperationalInternal": {"host": "packages-12-west.internal.npmjs.com", "tmp": "tmp/aes-js-1.0.0.tgz_1459638333821_0.1607301903422922"}, "directories": {}}, "2.0.0": {"name": "aes-js", "version": "2.0.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "node test/test-aes.js && node test/test-counter.js && node test/test-buffer.js && node test/test-errors.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "f387521168b36e123019901a0dfc3a3949825a22", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@2.0.0", "_shasum": "1240cdaca1814605b653278c675cd76940629787", "_from": ".", "_npmVersion": "2.15.1", "_nodeVersion": "4.4.3", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"shasum": "1240cdaca1814605b653278c675cd76940629787", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-2.0.0.tgz", "integrity": "sha512-WQnoWXoS/dkI1YBHNG0JDElqG4tu2KDpqcKvABhs2wHafJ+GjtN+QNqE6oVyZ3QWcMLzbQq5X4lGOAPQs9U7vQ==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQDDYnNIP0+YP4PIjPa/qp7P3n0kw0RsmlTHNKoqmPcIBAIgZUoWym08jaWSuo2rFSdMQFoWcoLZCyVB40tSxjrKYGU="}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "packages-16-east.internal.npmjs.com", "tmp": "tmp/aes-js-2.0.0.tgz_1463365603257_0.8474472321104258"}, "directories": {}}, "2.1.0": {"name": "aes-js", "version": "2.1.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "50f8606d83116dbe85303d89df8b820b2570b8b8", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@2.1.0", "_shasum": "2bf04b06a05fff29d38e9048ff30dc59f1f0cd74", "_from": ".", "_npmVersion": "2.15.1", "_nodeVersion": "4.4.3", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"shasum": "2bf04b06a05fff29d38e9048ff30dc59f1f0cd74", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-2.1.0.tgz", "integrity": "sha512-FnnPZLHldB0XCBOfDWBhAHwBLGkVRkA88Q6G6EvP/c+xwtNRVnZ0i5+dyUa5eu2Ko4B0uBRkMdPKhytcGj89Mg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQCMC5NdJgi8CcaKlYGosx7zJH24+Qxz6Q83oSIoHo3JtwIhAJosKaNQB5QLMIK7AaqAcpytObeCfxTAfOmmqDNR2tg5"}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "packages-16-east.internal.npmjs.com", "tmp": "tmp/aes-js-2.1.0.tgz_1475595009329_0.32095598871819675"}, "directories": {}}, "2.1.1": {"name": "aes-js", "version": "2.1.1", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "8d3fc6f350c0270acc5049d6e1b0e0c19d89036e", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@2.1.1", "_shasum": "68989763bbade2a39172ea48f4953d1272ff38a7", "_from": ".", "_npmVersion": "3.10.8", "_nodeVersion": "6.9.1", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"shasum": "68989763bbade2a39172ea48f4953d1272ff38a7", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-2.1.1.tgz", "integrity": "sha512-AbF8g0JGAX5i2LCR40ucsWOdANYmA65wmg+qZzDwXUw8QocSl4FE0Cv58HcM2jPZQYybsdFvgieXJgQjRi91qA==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDL93d2HNd/xE5s0gcoJVjfU/9wLl+aUqqu7ic+wSCP1AIhAP1YdZqs0iJPtoRipGvG+HVJNZeSQ9vjt6RqSb65FAQ/"}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "packages-12-west.internal.npmjs.com", "tmp": "tmp/aes-js-2.1.1.tgz_1486516694913_0.34495386155322194"}, "directories": {}}, "3.0.0": {"name": "aes-js", "version": "3.0.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "8ac229a01e5e44aa04012c75fa69222b3953456f", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@3.0.0", "_shasum": "e21df10ad6c2053295bcbb8dab40b09dbea87e4d", "_from": ".", "_npmVersion": "3.10.8", "_nodeVersion": "6.9.1", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"shasum": "e21df10ad6c2053295bcbb8dab40b09dbea87e4d", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-3.0.0.tgz", "integrity": "sha512-H7wUZRn8WpTq9jocdxQ2c8x2sKo9ZVmzfRE13GiNJXfp7NcKYEdvl3vspKjXox6RIG2VtaRe4JFvxG4rqp2Zuw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDHcDwNDCATbXzXquiynyghb3nAsM7TaTrxHylX6G7pjQIhAJBa+W4jJLVMxVUf2KqLGk1ykBcmnlKHNxEMVYS3aQeg"}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "packages-18-east.internal.npmjs.com", "tmp": "tmp/aes-js-3.0.0.tgz_1486544402452_0.7938876675907522"}, "directories": {}}, "3.1.0": {"name": "aes-js", "version": "3.1.0", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "583860cc04ca84e67b21bdffe9b9494da8fb0162", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@3.1.0", "_shasum": "f5f7588494526997cc635cc334c8bb8e967a5d82", "_from": ".", "_npmVersion": "3.10.8", "_nodeVersion": "6.9.1", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"shasum": "f5f7588494526997cc635cc334c8bb8e967a5d82", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-3.1.0.tgz", "integrity": "sha512-0LaGcbUzFVZxe84ban19SufQeJGuniF5YCnMvhTY8W5Qxc7x6WQpIvLSIRVnhPXzJJHl+Ocs23K7W8efLqtAOg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDpon9T6WMflI1/2ipf4Eqo5wATj7APDIWktJtYT0wU9wIhAMtpwegI3bGW6Hn8Wr9RcJfYE7+T9pQUbd2DRrUZkk7D"}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "packages-12-west.internal.npmjs.com", "tmp": "tmp/aes-js-3.1.0.tgz_1492284838664_0.6866449587978423"}, "directories": {}}, "3.1.1": {"name": "aes-js", "version": "3.1.1", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "^0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "64b5e74c0a6f2f8138c352ab3d0ac5aa769bfe7e", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@3.1.1", "_npmVersion": "5.6.0", "_nodeVersion": "8.9.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"integrity": "sha512-cEA0gBelItZZV7iBiL8ApCiNgc+gBWJJ4uoORhbu6vOqAJ0UL9wIlxr4RI7ij9SSVzy6AnPwiu37kVYiHCl3nw==", "shasum": "89fd1f94ae51b4c72d62466adc1a7323ff52f072", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-3.1.1.tgz", "fileCount": 14, "unpackedSize": 2430476, "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa0ma2CRA9TVsSAnZWagAAz28QAJhJuXeFakWOhLehHb6d\nAVyAscaNY9qrDpGfrjOFwFvmvWml1z0Vog5LbD8YUYEY3E9OTASQXfOKOkws\n96iuE4lnxPFnHxZDIOGoZ5DG9uj64MbBC+KYu7wCiB/Q7d01/PtW9KKb6brN\n/WTvmEt5XpcyKM0FROzxxW/tDScvWJfMghI08UYFmDY0G2cpyQ1w+jgoMOWX\nPI5naYtNLYHi30CeEAzq/CVP3gIMCcf/SYRerBXVnxMrLYZ999N6NDNB9j/Y\nouoN1MZhAz99MRNx4Tm8Ld9F3SY/25LAgVy7ezDLqNz7YwSZrocvwqrx7XZD\nR7wubBAzuDTXHETWEIc7Mm2DvK7DIGiFIgXFxRM5t7VFiBbxDqv4/rs9kxEn\np6grrF3IJs5LF3GMmDQdGly5/kSJE3tpcLALdy7lH4E+PFro59NPl4z0cAh9\nMvYIcRLcrHaBZ1v/uX+sfl2ijT+Kx68Q6OI4p9LJNsz+CNy5rgC5JenU0ZbD\nDpDM5le9TaT3aTfYdqvniug+ly8tcP6/6VMYHJKdzGmRattuuevMGuDAsHJp\nMvpao0YIFmEqNgX5hx5cs5SRMu+J1Kbz6d4xFDhmARMe1oFmsyhUjqVSHv/D\nffCCwEdpjfm1aCHlwHo81fDGQ8ZpsRTtoaMcR9sVy1VUIjgOdiOmhiydB3nm\ngCF/\r\n=7lVy\r\n-----END PGP SIGNATURE-----\r\n", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDJTe/VlB/Lq+/ZY5+ad/Z/V9rcIFePcnEpudqNMcjXRAIhANvUT6O7hEBzuv6NGTK/Xd29BkogSFlKKCKsIb1MAkxp"}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "directories": {}, "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_3.1.1_1523738293268_0.2848385073043558"}, "_hasShrinkwrap": false}, "3.1.2": {"name": "aes-js", "version": "3.1.2", "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"nodeunit": "^0.9.1"}, "main": "index.js", "scripts": {"test": "nodeunit test/index.js"}, "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "gitHead": "7c9fad4add4b349dcb89a4e2125f37defaef3bc8", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@3.1.2", "_npmVersion": "6.4.1", "_nodeVersion": "10.12.0", "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "dist": {"integrity": "sha512-e5pEa2kBnBOgR4Y/p20pskXI74UEz7de8ZGVo58asOtvSVG5YAbJeELPZxOmt+Bnz3rX753YKhfIn4X4l1PPRQ==", "shasum": "db9aabde85d5caabbfc0d4f2a4446960f627146a", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-3.1.2.tgz", "fileCount": 5, "unpackedSize": 80494, "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb5fbXCRA9TVsSAnZWagAAfMQQAKEqiznrh3l1+qI2pKdd\nhLbbSy748AnzQPw925BNJqqb12z1IR82Mz0Bl69fy/TMMSucZ/wcWlucNste\nb41ROptOUShO/SOJB92IvuGB6ilhaeB60CYvKDiPv+1X88VJ36EANUNu95sZ\nJLIehVSOrkSl3595WYAk6/wET6xKhcJH50V7mQmosNQAwr6IERNRK72fNyic\n+0LQM4z0FV+d/afVNMohQzVTy3CHCETRzDkWWZfo3GYM7e0oSfQvnaayGfiv\ngMSJyEKmjjVdg/jprUQ9VlNQWRDA59NIAm48m27nMOF7TilPh9FAX3NL0IRY\nphiZoQZ0fHgwFe5S6v0l7Kp5KEklQ5bqF1K99t7iv88FDJ+/MVOA829S3wS4\n83tYxe5VbkLZy2DhDayOAeFhp7O07SlPVzXq6w9NE3qR7Cp81bUcb8u0lpU1\nNgk/zw0watcaEJEEHGGJwDVDduzpcTaSquviRmrTYtU3AZFeFjkwjRbu6tuW\ns53XamGDTdbbnDsZv/jj4FkQH6WlL8j0KPc7u/Er4CV75lWJThJCB+wUsY/K\niqGqLYt/v+amfh/Hxg7Sv+ymSBmORMBbUzqBLNVTHL2pFekr8sxAdbzUNDSS\nqerxm7y1byc41x3UZIQvjizu0ynfiqEtAcTkErVNEGl6J4PiKu8fWYR8g4az\nUE+E\r\n=hp35\r\n-----END PGP SIGNATURE-----\r\n", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCICkQ2YJ8VynmCJlRLV35KPt4YTwz+w+N4N5HdGX22bbHAiB4RtVgC7mEXZ2/kNx3HjyhhPs2pk6XA0H47aL2UL+q7w=="}]}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "directories": {}, "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_3.1.2_1541797590785_0.9621898095904673"}, "_hasShrinkwrap": false}, "4.0.0-beta.1": {"name": "aes-js", "version": "4.0.0-beta.1", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"@types/mocha": "^9.1.0", "@types/node": "^16.7.10", "mocha": "^9.2.2", "typescript": "^4.6.2"}, "scripts": {"build": "tsc --build ./tsconfig.json", "auto-build": "npm run build -- -w", "test": "mocha ./lib/tests.js"}, "main": "./lib/index.js", "publishConfig": {"tag": "beta"}, "type": "module", "types": "./lib/types.d.ts", "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\nMigrating from 2.x to 3.x\n-------------------------\n\nThe utility functions have been renamed in the 3.x branch, since they were causing a great deal of confusion converting between bytes and string.\n\nThe examples have also been updated to encode binary data as printable hex strings.\n\n**Strings and Bytes**\n\nStrings should **NOT** be used as keys. UTF-8 allows variable length, multi-byte characters, so a string that is 16 *characters* long may not be 16 *bytes* long.\n\nAlso, UTF8 should **NOT** be used to store arbitrary binary data as it is a *string* encoding format, not a *binary* encoding format.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString)\n// Becomes:\naesjs.utils.utf8.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString)\n// Becomes:\naesjs.utils.utf8.fromBytes(aString)\n```\n\n**Bytes and Hex strings**\n\nBinary data, such as encrypted bytes, can safely be stored and printed as hexidecimal strings.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString, 'hex')\n// Becomes:\naesjs.utils.hex.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString, 'hex')\n// Becomes:\naesjs.utils.hex.fromBytes(aString)\n```\n\n**Typed Arrays**\n\nThe 3.x and above versions of aes-js use [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instead of Array, which reduces code size when used with Browserify (it no longer pulls in Buffer) and is also about **twice** the speed.\n\nHowever, if you need to support browsers older than IE 10, you should continue using version 2.x.\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.\n\nThe library work with `Array`, `Uint8Array` and `Buffer` objects as well as any *array-like* object (i.e. must have a `length` property, and have a valid byte value for each entry).\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, you may use Uint8Array:\nvar key_128_array = new Uint8Array(key_128);\nvar key_192_array = new Uint8Array(key_192);\nvar key_256_array = new Uint8Array(key_256);\n\n// or, you may use Buffer in node.js:\nvar key_128_buffer = Buffer.from(key_128);\nvar key_192_buffer = Buffer.from(key_192);\nvar key_256_buffer = Buffer.from(key_256);\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/package/scrypt-js) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\n// An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The counter is optional, and if omitted will begin at 1\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87\n//  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (text must be a multiple of 16 bytes)\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"104fb073f9a131f2cab49184bb864ca2\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (must be a multiple of the segment size you choose below)\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar segmentSize = 8;\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, segmentSize);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2638c560b4fdb9d26a630733ea60197ec23deb85b1f60f71f10409ce27\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2655dd72b9f32456042f39bae9accff6259159e608be55a1aa313c598d\n//  b4b18406d89c83841c9d1af13b56de8eda8fcfe9ec8e75e8\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a7d93b35368519fac347498dec18b458\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.utils.utf8.toBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"880fc7ae7685e9b18f2f2ad360376b6d\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Ethereum - `0x70bDC274028F3f391E398dF8e3977De64FEcBf04`\n", "readmeFilename": "README.md", "gitHead": "bad4bb2d4f957358cf383d5f75af8db2a2b3b9d8", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@4.0.0-beta.1", "_nodeVersion": "12.20.0", "_npmVersion": "6.14.8", "dist": {"integrity": "sha512-rarTfcnExqXDRPTKRHnDMlcrZm6OGT0QU+nb8T/+TabEJoQtthPIPG6654J5gpv/f5Gj46H5alD+la7apLVelQ==", "shasum": "0e60b3b253d9f90ec326fa37744d3fb9f7baa28e", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-4.0.0-beta.1.tgz", "fileCount": 50, "unpackedSize": 298007, "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOrTmACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrX9Q/8Cx3kV9FC0UcNi2a13FNmL/8yTLa1eM3ay9GxA9BWJSXtg9qA\r\nB+NTjwEMdupZtiAsNg4FOL8Omj0DKvA08zbaOCBzkRaSUaIGYrrDqGkIhHV8\r\nuZNsfjgkPWoDiN5j9Soj+PjF6C4QurN/OMadl8jyc8aml8xPxPtLrjjcBKIw\r\nJo1yyejsxqbfkgiJOB/xRPAAqM66QXrDsrVwIWgtKBttGo7uXe+sH3ilXzQ3\r\nMEMf6VDco9nbXIXHjQ7OTcIOJ31Ng8oOupMktjRctshU2zfO7m2SURTHbSVY\r\nFqeF967MdU6BY7a9Zh2Zf7cfF6TAd+yNziT0ph+k16Q/wx8cpvIVG7llVI4G\r\nptYlsAIoRhlApLgtsKjhsKAtJgflpanwKUU527q8HVuy6AYvewtkkW7eNJBB\r\nEQeEu6dGpeZ8fGtt1EVaVMvNlDIkwh8eKYxVvt4BfrWfjCeBnJHIHstP9TFU\r\noxAB9rXeYq9V4juOlSlzb1eJ8FZqxNc3u9LoTqCvn5V//6RXUMf8BIiJXqeQ\r\n+oNUKla87xANxYZF6TnM2y0wGJ5CwdcRh/bVpJPi/QyKhMMLSDaPCBLwhs7A\r\n+B2hX1CI+xgQNIcaImJ4sI9nc+6rpeJ37Cq3q0PhCyC7/E5LVGjrLOZoXz5Y\r\nUd/4kNOkWT5/cL9yEXeGzooHV1ZePwBMpfU=\r\n=7/Yn\r\n-----END PGP SIGNATURE-----\r\n", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIGHQB3ZUNRBzngStytAxt6dcQr/iPrXTPDuBI9oDQcWgAiEAyifx8+24RExqVHfL/wFzzHFJIiHC6JSteVflUg7q4NY="}]}, "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "directories": {}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_4.0.0-beta.1_1648014566207_0.5539909044945062"}, "_hasShrinkwrap": false}, "4.0.0-beta.2": {"name": "aes-js", "version": "4.0.0-beta.2", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"@types/mocha": "^9.1.0", "@types/node": "^16.7.10", "mocha": "^9.2.2", "typescript": "^4.6.2"}, "scripts": {"build": "tsc --build ./tsconfig.json", "auto-build": "npm run build -- -w", "test": "mocha ./lib/tests.js"}, "main": "./lib/index.js", "publishConfig": {"tag": "beta"}, "type": "module", "types": "./lib/index.d.ts", "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\nMigrating from 2.x to 3.x\n-------------------------\n\nThe utility functions have been renamed in the 3.x branch, since they were causing a great deal of confusion converting between bytes and string.\n\nThe examples have also been updated to encode binary data as printable hex strings.\n\n**Strings and Bytes**\n\nStrings should **NOT** be used as keys. UTF-8 allows variable length, multi-byte characters, so a string that is 16 *characters* long may not be 16 *bytes* long.\n\nAlso, UTF8 should **NOT** be used to store arbitrary binary data as it is a *string* encoding format, not a *binary* encoding format.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString)\n// Becomes:\naesjs.utils.utf8.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString)\n// Becomes:\naesjs.utils.utf8.fromBytes(aString)\n```\n\n**Bytes and Hex strings**\n\nBinary data, such as encrypted bytes, can safely be stored and printed as hexidecimal strings.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString, 'hex')\n// Becomes:\naesjs.utils.hex.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString, 'hex')\n// Becomes:\naesjs.utils.hex.fromBytes(aString)\n```\n\n**Typed Arrays**\n\nThe 3.x and above versions of aes-js use [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instead of Array, which reduces code size when used with Browserify (it no longer pulls in Buffer) and is also about **twice** the speed.\n\nHowever, if you need to support browsers older than IE 10, you should continue using version 2.x.\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.\n\nThe library work with `Array`, `Uint8Array` and `Buffer` objects as well as any *array-like* object (i.e. must have a `length` property, and have a valid byte value for each entry).\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, you may use Uint8Array:\nvar key_128_array = new Uint8Array(key_128);\nvar key_192_array = new Uint8Array(key_192);\nvar key_256_array = new Uint8Array(key_256);\n\n// or, you may use Buffer in node.js:\nvar key_128_buffer = Buffer.from(key_128);\nvar key_192_buffer = Buffer.from(key_192);\nvar key_256_buffer = Buffer.from(key_256);\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/package/scrypt-js) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\n// An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The counter is optional, and if omitted will begin at 1\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87\n//  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (text must be a multiple of 16 bytes)\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"104fb073f9a131f2cab49184bb864ca2\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (must be a multiple of the segment size you choose below)\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar segmentSize = 8;\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, segmentSize);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2638c560b4fdb9d26a630733ea60197ec23deb85b1f60f71f10409ce27\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2655dd72b9f32456042f39bae9accff6259159e608be55a1aa313c598d\n//  b4b18406d89c83841c9d1af13b56de8eda8fcfe9ec8e75e8\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a7d93b35368519fac347498dec18b458\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.utils.utf8.toBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"880fc7ae7685e9b18f2f2ad360376b6d\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Ethereum - `0x70bDC274028F3f391E398dF8e3977De64FEcBf04`\n", "readmeFilename": "README.md", "gitHead": "66b70f511b31bbdba28c1102ba6db8e963c44c70", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@4.0.0-beta.2", "_nodeVersion": "12.20.0", "_npmVersion": "6.14.8", "dist": {"integrity": "sha512-j6ogLm5hqIjFR4E0YMqsFn39PKKdtqMkVZGWKS4TsAXQ2dk4nWhoMjt9BI4W+GwA6n8dFbfgQYIzS1k9kUfwoQ==", "shasum": "aa4be872a515eac7b54878819864539c9e7401a9", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-4.0.0-beta.2.tgz", "fileCount": 49, "unpackedSize": 273909, "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOrbeACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoKkw//Y7xCQ5rE1EEAV9EQeXL3itlKVw57Sh1V6/m66LSbnAXPLyfo\r\nh40bmKYSVgua2ujT/flsDktoMgHWOeRsH7H1PXKdWH3QP0VBreyZiV3G44/j\r\nklM0f0ivSdAEojpSfSdrembiNPF2SVEnTp+c7F001QFqea4SjAmgBGWJ+81C\r\n3IgQZgbh9lxBZn1R7Ag5A+/huWEo+o8xc7S8HRmiTO7suLmXGurqdAyD8cQS\r\npJLiPxwMYibht2qEwzXhLBHfCusrlyty8xH+JuLODsjieUagZpRxEBXvwNz5\r\n8rZNmFOvmpy4wH89bfYOTM2Qd3pWE18k40HC3FAmFKNwIAh24POSYh3x74RX\r\nUoLYRnsjA7yQ5cNwyqAUYc3+NPGMbS/cfdhKimynj6UzQhEs5wbwA9YpllWh\r\nG7X6+/vDfXnHLJl3F1yJ34kSOBSnH14mzqGiHO2lCAwb/hvs9DoyPUzi9jzc\r\n7Z5EqNzvIWdLkTOZ+W2SSCTintw1tqeAKot7nI5Jne8dFYkR1jAG2HIbFcSW\r\n9mJOBtqnww/Gi/E//dG8J3zru6/MXid71UUFkRQleD5SLuFP97xrbrRhpQIG\r\nWsWce0qt9btc3Cjg7smQeeU+mbw0XY8ZwPSv6TKoMszRNuA1PiokQ8S9y4zs\r\nSbDYkYt2dtHDbR2u/slBi3l3L3gUv7tnYUo=\r\n=mOk9\r\n-----END PGP SIGNATURE-----\r\n", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCICNkCBbVLUNCbzN8gd7Vo5pxPkU10r5mXrluVqARQlNLAiEA3Bf/Wyv/q5NtEiWO52lB8ZcJ/B0q0Ky5h3sMoxIPhtU="}]}, "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "directories": {}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_4.0.0-beta.2_1648015070864_0.9524116183291118"}, "_hasShrinkwrap": false}, "4.0.0-beta.3": {"name": "aes-js", "version": "4.0.0-beta.3", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"@types/mocha": "^9.1.0", "@types/node": "^16.7.10", "mocha": "^9.2.2", "typescript": "^4.7.4"}, "exports": {".": {"import": "./lib.esm/index.js", "require": "./lib.commonjs/index.js", "types": "./types/index.d.ts"}}, "scripts": {"auto-build": "npm run build -- -w", "build": "tsc --build ./tsconfig.esm.json", "build-all": "npm run build && npm run build-commonjs && npm run build-types", "build-clean": "npm run clean && npm run build-all", "build-commonjs": "tsc --build ./tsconfig.commonjs.json && cp ./package-commonjs.json ./lib.commonjs/package.json", "build-types": "tsc --build ./tsconfig.types.json", "clean": "rm -rf dist lib.commonjs lib.esm types", "test-commonjs": "mocha ./lib.commonjs/tests.js", "test-esm": "mocha ./lib.esm/tests.js", "test": "npm run test-commonjs && npm run test-esm"}, "main": "./lib.commonjs/index.js", "module": "./lib.esm/index.js", "publishConfig": {"tag": "beta"}, "sideEffects": false, "type": "module", "types": "./types/index.d.ts", "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\nMigrating from 2.x to 3.x\n-------------------------\n\nThe utility functions have been renamed in the 3.x branch, since they were causing a great deal of confusion converting between bytes and string.\n\nThe examples have also been updated to encode binary data as printable hex strings.\n\n**Strings and Bytes**\n\nStrings should **NOT** be used as keys. UTF-8 allows variable length, multi-byte characters, so a string that is 16 *characters* long may not be 16 *bytes* long.\n\nAlso, UTF8 should **NOT** be used to store arbitrary binary data as it is a *string* encoding format, not a *binary* encoding format.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString)\n// Becomes:\naesjs.utils.utf8.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString)\n// Becomes:\naesjs.utils.utf8.fromBytes(aString)\n```\n\n**Bytes and Hex strings**\n\nBinary data, such as encrypted bytes, can safely be stored and printed as hexidecimal strings.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString, 'hex')\n// Becomes:\naesjs.utils.hex.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString, 'hex')\n// Becomes:\naesjs.utils.hex.fromBytes(aString)\n```\n\n**Typed Arrays**\n\nThe 3.x and above versions of aes-js use [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instead of Array, which reduces code size when used with Browserify (it no longer pulls in Buffer) and is also about **twice** the speed.\n\nHowever, if you need to support browsers older than IE 10, you should continue using version 2.x.\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.\n\nThe library work with `Array`, `Uint8Array` and `Buffer` objects as well as any *array-like* object (i.e. must have a `length` property, and have a valid byte value for each entry).\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, you may use Uint8Array:\nvar key_128_array = new Uint8Array(key_128);\nvar key_192_array = new Uint8Array(key_192);\nvar key_256_array = new Uint8Array(key_256);\n\n// or, you may use Buffer in node.js:\nvar key_128_buffer = Buffer.from(key_128);\nvar key_192_buffer = Buffer.from(key_192);\nvar key_256_buffer = Buffer.from(key_256);\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/package/scrypt-js) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\n// An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The counter is optional, and if omitted will begin at 1\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87\n//  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (text must be a multiple of 16 bytes)\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"104fb073f9a131f2cab49184bb864ca2\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (must be a multiple of the segment size you choose below)\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar segmentSize = 8;\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, segmentSize);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2638c560b4fdb9d26a630733ea60197ec23deb85b1f60f71f10409ce27\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2655dd72b9f32456042f39bae9accff6259159e608be55a1aa313c598d\n//  b4b18406d89c83841c9d1af13b56de8eda8fcfe9ec8e75e8\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a7d93b35368519fac347498dec18b458\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.utils.utf8.toBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"880fc7ae7685e9b18f2f2ad360376b6d\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Ethereum - `0x70bDC274028F3f391E398dF8e3977De64FEcBf04`\n", "readmeFilename": "README.md", "gitHead": "b952d23ff27afcfab8eabda5cf033d2ea819ba97", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@4.0.0-beta.3", "_nodeVersion": "18.7.0", "_npmVersion": "8.15.0", "dist": {"integrity": "sha512-/xJX0/VTPcbc5xQE2VUP91y1xN8q/rDfhEzLm+vLc3hYvb5+qHCnpJRuFcrKn63zumK/sCwYYzhG8HP78JYSTA==", "shasum": "da2253f0ff03a0b3a9e445c8cbdf78e7fda7d48c", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-4.0.0-beta.3.tgz", "fileCount": 76, "unpackedSize": 410534, "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIDphYQFE9L6W3cLUFOKxnUzZywpzhZL74P0xk5Onhu1cAiEA7TaCzJ+8QIjYtS48zEcqh9eWw3/qI+QJXn67FQUZDM0="}], "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjMpDgACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrEvxAAiKJHZzxloDsWYtJ/sbewuVbGspq4lJCPSsVKDUqhVLsiT6I5\r\noiDvHwQYnq1+fxJdA+cXy2vT7GI05noUVauzd+mGpjF8ixSjDkvZJn4JqnPp\r\n5f2pFRewA3/iIPn3kwcTKWRSnxIgvXedEu/4YjX7sVY0wEniS4/uZVxrWUaw\r\noD8nm9z87VCqqZuyL8w7wNBx3McaLjGhutInKNkx361832jzkCIg+Ea3YuEc\r\nEzLrO6c3q7nrMrrLh5rIeK4b3hSNA0XktOYTAclthP3u8ggQWWYnJBmVCmbD\r\ndZIZ4Qd56xFowyNCt9AddoSRFNK1xtsLevjPf2cesJMOyyL6HwdMWCEmvxqe\r\nUsscnjRSgfBrBTeZB6PhgavognXzMDzATWhghyllkTv0XSygKMvYzi6hh+SD\r\n9ANHvFvv95gZHB3lfe0pVnN7IpTNGN7MerZsrJQaIATZMWNPNWAigMBGCXoQ\r\nLOxUZwhpl/etqzkdkJq+BmTyFiI7kRq8mfQ8fvHiQMGLu77KCNx39kKfrvDU\r\nFWHSn9KnYcq3sbj5WNvhZw43zOVPSGZVJ//P53flURqInA/A1J2i0mggSKLk\r\nxQB8cVy5gH+p25TTT2rU9mPfm+XSX9nG0evmHTKDdLVG+8hgkZvKaakN23d0\r\nh0Vtv9VauRxvK3PDgADsQL/LlKfE5CxdStE=\r\n=glq6\r\n-----END PGP SIGNATURE-----\r\n"}, "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "directories": {}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_4.0.0-beta.3_1664258271938_0.28851671232253273"}, "_hasShrinkwrap": false}, "4.0.0-beta.4": {"name": "aes-js", "version": "4.0.0-beta.4", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"@types/mocha": "^9.1.0", "@types/node": "^16.7.10", "mocha": "^9.2.2", "typescript": "^4.7.4"}, "exports": {".": {"import": "./lib.esm/index.js", "require": "./lib.commonjs/index.js", "types": "./types/index.d.ts", "default": "./lib.commonjs/index.js"}}, "scripts": {"auto-build": "npm run build -- -w", "build": "tsc --build ./tsconfig.esm.json", "build-all": "npm run build && npm run build-commonjs && npm run build-types", "build-clean": "npm run clean && npm run build-all", "build-commonjs": "tsc --build ./tsconfig.commonjs.json && cp ./package-commonjs.json ./lib.commonjs/package.json", "build-types": "tsc --build ./tsconfig.types.json", "clean": "rm -rf dist lib.commonjs lib.esm types", "test-commonjs": "mocha ./lib.commonjs/tests.js", "test-esm": "mocha ./lib.esm/tests.js", "test": "npm run test-commonjs && npm run test-esm"}, "main": "./lib.commonjs/index.js", "module": "./lib.esm/index.js", "publishConfig": {"tag": "beta"}, "sideEffects": false, "types": "./types/index.d.ts", "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\nMigrating from 2.x to 3.x\n-------------------------\n\nThe utility functions have been renamed in the 3.x branch, since they were causing a great deal of confusion converting between bytes and string.\n\nThe examples have also been updated to encode binary data as printable hex strings.\n\n**Strings and Bytes**\n\nStrings should **NOT** be used as keys. UTF-8 allows variable length, multi-byte characters, so a string that is 16 *characters* long may not be 16 *bytes* long.\n\nAlso, UTF8 should **NOT** be used to store arbitrary binary data as it is a *string* encoding format, not a *binary* encoding format.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString)\n// Becomes:\naesjs.utils.utf8.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString)\n// Becomes:\naesjs.utils.utf8.fromBytes(aString)\n```\n\n**Bytes and Hex strings**\n\nBinary data, such as encrypted bytes, can safely be stored and printed as hexidecimal strings.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString, 'hex')\n// Becomes:\naesjs.utils.hex.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString, 'hex')\n// Becomes:\naesjs.utils.hex.fromBytes(aString)\n```\n\n**Typed Arrays**\n\nThe 3.x and above versions of aes-js use [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instead of Array, which reduces code size when used with Browserify (it no longer pulls in Buffer) and is also about **twice** the speed.\n\nHowever, if you need to support browsers older than IE 10, you should continue using version 2.x.\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.\n\nThe library work with `Array`, `Uint8Array` and `Buffer` objects as well as any *array-like* object (i.e. must have a `length` property, and have a valid byte value for each entry).\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, you may use Uint8Array:\nvar key_128_array = new Uint8Array(key_128);\nvar key_192_array = new Uint8Array(key_192);\nvar key_256_array = new Uint8Array(key_256);\n\n// or, you may use Buffer in node.js:\nvar key_128_buffer = Buffer.from(key_128);\nvar key_192_buffer = Buffer.from(key_192);\nvar key_256_buffer = Buffer.from(key_256);\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/package/scrypt-js) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\n// An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The counter is optional, and if omitted will begin at 1\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87\n//  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (text must be a multiple of 16 bytes)\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"104fb073f9a131f2cab49184bb864ca2\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (must be a multiple of the segment size you choose below)\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar segmentSize = 8;\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, segmentSize);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2638c560b4fdb9d26a630733ea60197ec23deb85b1f60f71f10409ce27\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2655dd72b9f32456042f39bae9accff6259159e608be55a1aa313c598d\n//  b4b18406d89c83841c9d1af13b56de8eda8fcfe9ec8e75e8\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a7d93b35368519fac347498dec18b458\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.utils.utf8.toBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"880fc7ae7685e9b18f2f2ad360376b6d\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Ethereum - `0x70bDC274028F3f391E398dF8e3977De64FEcBf04`\n", "readmeFilename": "README.md", "gitHead": "38cc5187696e8eb34ed6bcf102c8abd589b0b7a2", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@4.0.0-beta.4", "_nodeVersion": "18.15.0", "_npmVersion": "9.5.0", "dist": {"integrity": "sha512-Lqs6zIA6b8xOVgbt2WUhm7l0W0BEFiPvTrEgxTdw+B/9YvqZwTP+o8qLiOcLtiEw6xf9WkwBvjxda7uRgcnAlQ==", "shasum": "77ce3e3872ccb0a0081339bbd11f5485d604481a", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-4.0.0-beta.4.tgz", "fileCount": 81, "unpackedSize": 411648, "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCIHBBj8sK60swQD0yjKxKfSDB4cB+qn6jDwi2/HCnrkEgAiB7LsVNDKOP5ov2tZLkaI+C9A/2S6Iiov42Invij321aA=="}], "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkR7ItACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqLSw/+LSQsb3SapNU85ZlZTul+cQ9mp6EEjjL8UqpCoWeSPsMqLVD4\r\nLOt3EuDLqDrhvOyhaEuU2r+t/6w2Sd0+KM0b05Kuv4Qa2FUphBTMC0YczDIf\r\nstrgpiyFThueKkksB/I1Y1h3vXeOpv7QN1taUfXjseXtE1dxbGSAmGH5ogSn\r\nWcRpjZsfOxGWa4CfwLqZhuND41y6bf8ugWgHs+PoRrnRw+uSoL9I2LkJvN7N\r\n6c0fxjZu2Gz7sbGy8ZD4Om0BZ9DXHQJ/L8yTahLKGbDgNFpll+etBCzSwIov\r\nhHOYdqttTQoklFaTiEFimv9aD+BwUplFQzIir66SDQzcbHWMAge0liBAXwuH\r\nm1gtn4i4E9mTXsEL9akczrC9OVNXGJAXUkdWVzO5oiPwgrLo5frNZKYRslJM\r\n0z1sv/NEjCyCi3fug3LE/5X1u+h/lRuA4umAZlJ27Huap3cmBHh71Ho5ATGe\r\nd5Bh+vFg0BPDuyc41JZTkNkKeCSDWwPLqSCQEOjy68A9pVdLVKahber/0J4f\r\nFGrslPufBr75EfEW4Kc5SYSLrBADSc4J4GFXNpcW0OAt91/LljtIqh+qSSaF\r\nBkR+gGzklVTAg0VzeP19imme+v6+J7FuMLiktrWE+aI4fwdgg66hXiD2+Mhq\r\nJ1aVsoVC+GwDGhnz+LEYiBW0Fsu4NpOjoDA=\r\n=vq4W\r\n-----END PGP SIGNATURE-----\r\n"}, "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "directories": {}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_4.0.0-beta.4_1682420269414_0.803055882524083"}, "_hasShrinkwrap": false}, "4.0.0-beta.5": {"name": "aes-js", "version": "4.0.0-beta.5", "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.", "devDependencies": {"@types/mocha": "^9.1.0", "@types/node": "^16.7.10", "mocha": "^9.2.2", "typescript": "^4.7.4"}, "exports": {".": {"import": "./lib.esm/index.js", "default": "./lib.commonjs/index.js"}}, "scripts": {"auto-build": "npm run build -- -w", "build": "tsc --build ./tsconfig.esm.json", "build-all": "npm run build && npm run build-commonjs", "build-clean": "npm run clean && npm run build-all", "build-commonjs": "tsc --build ./tsconfig.commonjs.json && cp ./package-commonjs.json ./lib.commonjs/package.json", "clean": "rm -rf lib.commonjs lib.esm && cp -r misc/basedirs/* .", "test-commonjs": "mocha ./lib.commonjs/tests.js", "test-esm": "mocha ./lib.esm/tests.js", "test": "npm run test-commonjs && npm run test-esm"}, "main": "./lib.commonjs/index.js", "module": "./lib.esm/index.js", "publishConfig": {"tag": "beta"}, "sideEffects": false, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "types": "./lib.commonjs/index.d.ts", "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\nMigrating from 2.x to 3.x\n-------------------------\n\nThe utility functions have been renamed in the 3.x branch, since they were causing a great deal of confusion converting between bytes and string.\n\nThe examples have also been updated to encode binary data as printable hex strings.\n\n**Strings and Bytes**\n\nStrings should **NOT** be used as keys. UTF-8 allows variable length, multi-byte characters, so a string that is 16 *characters* long may not be 16 *bytes* long.\n\nAlso, UTF8 should **NOT** be used to store arbitrary binary data as it is a *string* encoding format, not a *binary* encoding format.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString)\n// Becomes:\naesjs.utils.utf8.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString)\n// Becomes:\naesjs.utils.utf8.fromBytes(aString)\n```\n\n**Bytes and Hex strings**\n\nBinary data, such as encrypted bytes, can safely be stored and printed as hexidecimal strings.\n\n```javascript\n// aesjs.util.convertStringToBytes(aString, 'hex')\n// Becomes:\naesjs.utils.hex.toBytes(aString)\n\n\n// aesjs.util.convertBytesToString(aString, 'hex')\n// Becomes:\naesjs.utils.hex.fromBytes(aString)\n```\n\n**Typed Arrays**\n\nThe 3.x and above versions of aes-js use [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instead of Array, which reduces code size when used with Browserify (it no longer pulls in Buffer) and is also about **twice** the speed.\n\nHowever, if you need to support browsers older than IE 10, you should continue using version 2.x.\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.\n\nThe library work with `Array`, `Uint8Array` and `Buffer` objects as well as any *array-like* object (i.e. must have a `length` property, and have a valid byte value for each entry).\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, you may use Uint8Array:\nvar key_128_array = new Uint8Array(key_128);\nvar key_192_array = new Uint8Array(key_192);\nvar key_256_array = new Uint8Array(key_256);\n\n// or, you may use Buffer in node.js:\nvar key_128_buffer = Buffer.from(key_128);\nvar key_192_buffer = Buffer.from(key_192);\nvar key_256_buffer = Buffer.from(key_256);\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/package/scrypt-js) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\n// An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The counter is optional, and if omitted will begin at 1\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87\n//  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (text must be a multiple of 16 bytes)\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"104fb073f9a131f2cab49184bb864ca2\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes (must be a multiple of the segment size you choose below)\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar segmentSize = 8;\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, segmentSize);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2638c560b4fdb9d26a630733ea60197ec23deb85b1f60f71f10409ce27\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// The initialization vector (must be 16 bytes)\nvar iv = [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,35, 36 ];\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"55e3af2655dd72b9f32456042f39bae9accff6259159e608be55a1aa313c598d\n//  b4b18406d89c83841c9d1af13b56de8eda8fcfe9ec8e75e8\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\n// An example 128-bit key\nvar key = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ];\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.utils.utf8.toBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"a7d93b35368519fac347498dec18b458\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.utils.utf8.toBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n// To print or store the binary data, you may convert it to hex\nvar encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\nconsole.log(encryptedHex);\n// \"880fc7ae7685e9b18f2f2ad360376b6d\"\n\n// When ready to decrypt the hex string, convert it back to bytes\nvar encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Ethereum - `0x70bDC274028F3f391E398dF8e3977De64FEcBf04`\n", "readmeFilename": "README.md", "gitHead": "2dcb8d90c1d38fab36e5be14519099f8651dedc5", "homepage": "https://github.com/ricmoo/aes-js#readme", "_id": "aes-js@4.0.0-beta.5", "_nodeVersion": "18.15.0", "_npmVersion": "9.5.0", "dist": {"integrity": "sha512-G965FqalsNyrPqgEGON7nIx1e/OVENSgiEIzyC63haUMuvNnwIgIjMs52hlTCKhkBny7A2ORNlfY9Zu+jmGk1Q==", "shasum": "8d2452c52adedebc3a3e28465d858c11ca315873", "tarball": "https://mirrors.huaweicloud.com/repository/npm/aes-js/-/aes-js-4.0.0-beta.5.tgz", "fileCount": 108, "unpackedSize": 737817, "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQCmCZm9/MjETisQHbX2NAbsvP2B6ZPX0oiJ99CQk41yqwIhAPFJr0wN+KLJzSHnfgqm0P/cPGfs6nKgLhfAZEWfFUXI"}], "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkSl0wACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp7RRAAkjgnSQa9/mJXxcluvlLrIcG1YXVA43mVUfB/CIhpB11GwrIn\r\nMRrHyiYOR7axWDQikbuVQky2SRrW7uQmycRIcZWrWxZjglbYlABA/pY3pfY9\r\n2ULbWQoYDgJgYUpuLvFC7kp5OxWkXK1ULwSBedoXYHa1NOg1NFAScUBTOiii\r\nkh14yltN6BinfXXGz3RLPp3Qbp31sDF4wleidRyyK1SIHdZ5eCh53foI6bXL\r\nIE+/mY2CcnhkaNOpS0bGmdskqPRCIa8ZsL0piB0jstDYqzDb4vUy0bMWCngB\r\ndVz7a1kfFADnnRMJOB9JkMLVb0deUUZhYr0Wn/opGJR7urNo1H2M1e0SQTtI\r\nENPbCqaKdVehIlzAJMy6ixH8N1tGDL/fUfZ9b4cCdgktazW8t9LfMMnfPod+\r\nsOg4szd9A21epxWd7/fRcli42G3fqxSRmSz+A+IQUEoN/odyzwSwtVS1GeRN\r\noGfGOeGq7VT0ZPHfiWqS0xcfw58eA3fL8/5nT7tnZbRT03F19iSZOwyshgLt\r\n+LKMk/poq6LD0pN0ObXZJ28rmyzU0bb6Lm8pk4Iw2qOGdelROVMWVR7rPXve\r\nHako4P2Wb0fdjC2dpCPtSL7eOfen9QdcUALY2hvVHdKuhZZdgksfRsmr0ZfR\r\nW7YHWibkalAN8zH0KcSzrDgs2CCmT8QF15c=\r\n=AgtM\r\n-----END PGP SIGNATURE-----\r\n"}, "_npmUser": {"name": "ricmoo", "email": "me@ricmoo.com"}, "directories": {}, "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "_npmOperationalInternal": {"host": "s3://npm-registry-packages", "tmp": "tmp/aes-js_4.0.0-beta.5_1682595120576_0.5070522506543462"}, "_hasShrinkwrap": false}}, "readme": "", "maintainers": [{"name": "ricmoo", "email": "me@ricmoo.com"}], "time": {"modified": "2023-04-27T11:32:00.980Z", "created": "2015-03-04T06:57:51.062Z", "0.0.1": "2015-03-04T06:57:51.062Z", "0.0.2": "2015-03-06T00:27:12.394Z", "0.1.0": "2015-03-06T21:39:49.713Z", "0.2.0": "2015-09-15T20:44:14.549Z", "0.2.1": "2015-11-16T00:12:37.411Z", "0.2.2": "2016-02-02T15:58:46.574Z", "0.2.3": "2016-02-24T05:02:53.167Z", "0.2.4": "2016-02-27T07:42:25.353Z", "1.0.0": "2016-04-02T23:05:36.698Z", "2.0.0": "2016-05-16T02:26:45.141Z", "2.1.0": "2016-10-04T15:30:11.351Z", "2.1.1": "2017-02-08T01:18:15.149Z", "3.0.0": "2017-02-08T09:00:04.750Z", "3.1.0": "2017-04-15T19:34:01.051Z", "3.1.1": "2018-04-14T20:38:13.430Z", "3.1.2": "2018-11-09T21:06:30.920Z", "4.0.0-beta.1": "2022-03-23T05:49:26.385Z", "4.0.0-beta.2": "2022-03-23T05:57:50.983Z", "4.0.0-beta.3": "2022-09-27T05:57:52.187Z", "4.0.0-beta.4": "2023-04-25T10:57:49.617Z", "4.0.0-beta.5": "2023-04-27T11:32:00.834Z"}, "keywords": ["aes", "aes-ctr", "aes-ofb", "aes-ecb", "aes-cbc", "aes-cfb", "encrypt", "decrypt", "block", "cipher"], "author": {"name": "Richard Moore", "email": "me@ricmoo.com"}, "license": "MIT", "readmeFilename": "", "homepage": "https://github.com/ricmoo/aes-js#readme", "repository": {"type": "git", "url": "git://github.com/ricmoo/aes-js.git"}, "bugs": {"url": "http://github.com/ricmoo/aes-js/issues", "email": "github@ricmoo.com"}, "users": {"285858315": true, "shouze": true, "icerainnuaa": true, "ricmoo": true, "necromos": true, "mrzmmr": true, "sm1215": true, "majac": true, "leplay": true}}